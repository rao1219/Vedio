// Generated by CoffeeScript 1.7.1
var addDefault, addDescription, addSchemaDeclaration, async, buildArrayItemsRepr, buildArrayRepr, buildEnumAsSingleTypeRepr, buildEnumGroupRepr, buildEnumRepr, buildEnumValuesRepr, buildFixedItemsRepr, buildObjectRepr, buildTupleItemsRepr, buildValueRepr, coerceLiteral, coerceLiterals, coerceNestedLiteral, createElementHandler, groupItemsByPrimitiveTypes, groupResolvedProperties, handleArrayElement, handleElement, handleEnumElement, handleObjectElement, handlePrimitiveElement, inspect, inspectEnum, inspectEnumInline, inspectEnumItems, resolveItem, resolveItems, resolveProperties, resolveProperty, resolveType, resolveTypes, transform, _ref, _ref1,
  __hasProp = {}.hasOwnProperty;

async = require('async');

inspect = require('../inspect');

_ref = require('../typeresolution'), resolveType = _ref.resolveType, resolveTypes = _ref.resolveTypes;

_ref1 = require('../jsonutils'), coerceLiteral = _ref1.coerceLiteral, coerceNestedLiteral = _ref1.coerceNestedLiteral;

coerceLiterals = function(literals, typeName, cb) {
  return async.mapSeries(literals, function(literal, next) {
    return coerceLiteral(literal, typeName, next);
  }, cb);
};

addDescription = function(element, repr, cb) {
  var desc;
  desc = inspect.findDescription(element);
  if (desc) {
    repr.description = desc;
  }
  return cb(null, repr);
};

addDefault = function(element, resolvedType, repr, cb) {
  var val;
  val = inspect.findDefault(element);
  if (!val) {
    return cb(null, repr);
  }
  return coerceNestedLiteral(val.literal, resolvedType.nested, function(err, defaultValue) {
    if (!err) {
      repr["default"] = defaultValue;
    }
    return cb(err, repr);
  });
};

resolveProperty = function(prop, inherited, cb) {
  if (prop["class"] === 'oneOf') {
    return cb(null, {});
  }
  return handleElement(prop, inherited, function(err, repr) {
    if (err) {
      return cb(err);
    }
    return cb(null, {
      name: inspect.findPropertyName(prop),
      variableName: inspect.hasVariablePropertyName(prop),
      repr: repr,
      required: inspect.isRequired(prop, inherited)
    });
  });
};

resolveProperties = function(props, inherited, cb) {
  return async.mapSeries(props, function(prop, next) {
    return resolveProperty(prop, inherited, next);
  }, cb);
};

groupResolvedProperties = function(resolvedProps, cb) {
  var groups, resolvedProp, _i, _len;
  groups = {
    regularProps: [],
    variableProps: [],
    requiredProps: []
  };
  for (_i = 0, _len = resolvedProps.length; _i < _len; _i++) {
    resolvedProp = resolvedProps[_i];
    if (resolvedProp.required) {
      groups.requiredProps.push(resolvedProp);
    }
    if (resolvedProp.variableName) {
      groups.variableProps.push(resolvedProp);
    } else {
      groups.regularProps.push(resolvedProp);
    }
  }
  return cb(null, groups);
};

buildObjectRepr = function(_arg, cb) {
  var fixed, repr, resolvedProps;
  resolvedProps = _arg.resolvedProps, fixed = _arg.fixed;
  repr = {
    type: 'object'
  };
  if (fixed) {
    repr.additionalProperties = false;
  }
  if (resolvedProps.length) {
    return groupResolvedProperties(resolvedProps, function(err, allProps) {
      var propsRepr, regularProps, requiredProps, rp, variableProps, _i, _len;
      if (err) {
        return cb(err);
      }
      regularProps = allProps.regularProps, variableProps = allProps.variableProps, requiredProps = allProps.requiredProps;
      if (regularProps.length) {
        propsRepr = {};
        for (_i = 0, _len = regularProps.length; _i < _len; _i++) {
          rp = regularProps[_i];
          propsRepr[rp.name] = rp.repr;
        }
        repr.properties = propsRepr;
      }
      if (variableProps.length === 1) {
        repr.patternProperties = {
          '': variableProps[0].repr
        };
      } else if (variableProps.length > 1) {
        repr.patternProperties = {
          '': {}
        };
      }
      if (requiredProps.length) {
        repr.required = (function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = requiredProps.length; _j < _len1; _j++) {
            rp = requiredProps[_j];
            _results.push(rp.name);
          }
          return _results;
        })();
      }
      return cb(null, repr);
    });
  } else {
    return cb(null, repr);
  }
};

handleObjectElement = function(objectElement, resolvedType, inherited, cb) {
  var fixed, heritage, props;
  fixed = inspect.isOrInheritsFixed(objectElement, inherited);
  heritage = inspect.getHeritage(fixed);
  props = inspect.listProperties(objectElement);
  return resolveProperties(props, heritage, function(err, resolvedProps) {
    if (err) {
      return cb(err);
    }
    return buildObjectRepr({
      resolvedProps: resolvedProps,
      fixed: fixed
    }, cb);
  });
};

resolveItem = function(item, inherited, cb) {
  return handleElement(item, inherited, function(err, repr) {
    if (err) {
      return cb(err);
    }
    return cb(null, {
      repr: repr,
      fixed: inspect.isFixed(item)
    });
  });
};

resolveItems = function(items, inherited, cb) {
  return async.mapSeries(items, function(item, next) {
    return resolveItem(item, inherited, next);
  }, cb);
};

buildValueRepr = function(val, typeName, cb) {
  var repr;
  repr = {
    type: typeName
  };
  if (val.variable) {
    return cb(null, repr);
  } else {
    return coerceLiteral(val.literal, typeName, function(err, coercedVal) {
      if (err) {
        return cb(err);
      }
      repr["enum"] = [coercedVal];
      return cb(null, repr);
    });
  }
};

buildTupleItemsRepr = function(arrayElement, resolvedItems, resolvedType, cb) {
  var nestedTypeName, ri, vals;
  if (resolvedItems.length) {
    return cb(null, (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = resolvedItems.length; _i < _len; _i++) {
        ri = resolvedItems[_i];
        _results.push(ri.repr);
      }
      return _results;
    })());
  }
  if (resolvedType.nested.length > 1) {
    return cb(new Error("Multiple nested types for fixed array."));
  }
  nestedTypeName = resolvedType.nested[0];
  vals = inspect.listValues(arrayElement);
  return async.mapSeries(vals, function(val, next) {
    return buildValueRepr(val, nestedTypeName, next);
  }, cb);
};

buildFixedItemsRepr = function(resolvedItems, cb) {
  var reprs, ri;
  reprs = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = resolvedItems.length; _i < _len; _i++) {
      ri = resolvedItems[_i];
      if (ri.fixed) {
        _results.push(ri.repr);
      }
    }
    return _results;
  })();
  if (reprs.length !== resolvedItems.length) {
    return cb(new Error("Array can't contain fixed items alongside with non-fixed ones."));
  }
  if (reprs.length === 1) {
    return cb(null, reprs[0]);
  }
  return cb(null, {
    anyOf: reprs
  });
};

buildArrayItemsRepr = function(_arg, cb) {
  var arrayElement, fixed, resolvedItems, resolvedType, ri;
  arrayElement = _arg.arrayElement, resolvedItems = _arg.resolvedItems, resolvedType = _arg.resolvedType, fixed = _arg.fixed;
  if (fixed) {
    return buildTupleItemsRepr(arrayElement, resolvedItems, resolvedType, cb);
  } else if (((function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = resolvedItems.length; _i < _len; _i++) {
      ri = resolvedItems[_i];
      if (ri.fixed) {
        _results.push(ri);
      }
    }
    return _results;
  })()).length) {
    return buildFixedItemsRepr(resolvedItems, cb);
  } else {
    return cb();
  }
};

buildArrayRepr = function(context, cb) {
  return buildArrayItemsRepr(context, function(err, itemsRepr) {
    var repr;
    if (err) {
      return cb(err);
    }
    repr = {
      type: 'array'
    };
    if (itemsRepr) {
      repr.items = itemsRepr;
    }
    return cb(null, repr);
  });
};

handleArrayElement = function(arrayElement, resolvedType, inherited, cb) {
  var fixed, heritage, items;
  if (inspect.isSample(arrayElement)) {
    return cb(null, {
      type: resolvedType.name
    });
  }
  fixed = inspect.isOrInheritsFixed(arrayElement, inherited);
  heritage = inspect.getHeritage(fixed, resolvedType);
  items = inspect.listItems(arrayElement);
  return resolveItems(items, heritage, function(err, resolvedItems) {
    if (err) {
      return cb(err);
    }
    return buildArrayRepr({
      arrayElement: arrayElement,
      resolvedItems: resolvedItems,
      resolvedType: resolvedType,
      fixed: fixed
    }, cb);
  });
};

buildEnumValuesRepr = function(group, inline, cb) {
  var item, literals, typeName, val, values, _i, _len, _ref2;
  typeName = group.typeName;
  if (inline) {
    literals = (function() {
      var _i, _len, _ref2, _results;
      _ref2 = group.values;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        val = _ref2[_i];
        _results.push(val.literal);
      }
      return _results;
    })();
  } else {
    literals = [];
    _ref2 = group.items;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      item = _ref2[_i];
      values = inspect.listValues(item);
      if (values.length) {
        literals.push(values[0].literal);
      }
    }
  }
  return coerceLiterals(literals, typeName, function(err, reprs) {
    var repr;
    if (err) {
      return cb(err);
    }
    repr = {
      type: typeName
    };
    if (reprs.length) {
      repr["enum"] = reprs;
    }
    return cb(null, repr);
  });
};

buildEnumAsSingleTypeRepr = function(group, cb) {
  return cb(null, {
    type: group.typeName
  });
};

buildEnumGroupRepr = function(group, inherited, inline, cb) {
  switch (group.strategy) {
    case 'types':
      return buildEnumTypesRepr(group, inherited, cb);
    case 'singleType':
      return buildEnumAsSingleTypeRepr(group, cb);
    default:
      return buildEnumValuesRepr(group, inline, cb);
  }
};

buildEnumRepr = function(_arg, cb) {
  var groups, inherited, inline, nonPrimitiveItems;
  groups = _arg.groups, inherited = _arg.inherited, inline = _arg.inline, nonPrimitiveItems = _arg.nonPrimitiveItems;
  return async.parallel({
    groupsReprs: function(next) {
      return async.map(groups, function(group, done) {
        return buildEnumGroupRepr(group, inherited, inline, done);
      }, next);
    },
    reprs: function(next) {
      return resolveItems(nonPrimitiveItems, inherited, function(err, resolvedItems) {
        var ri;
        return next(err, (!err ? (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = resolvedItems.length; _i < _len; _i++) {
            ri = resolvedItems[_i];
            _results.push(ri.repr);
          }
          return _results;
        })() : void 0));
      });
    }
  }, function(err, _arg1) {
    var groupsReprs, repr, reprs;
    groupsReprs = _arg1.groupsReprs, reprs = _arg1.reprs;
    if (err) {
      return cb(err);
    }
    reprs = reprs.concat(groupsReprs);
    repr = reprs.length > 1 ? {
      anyOf: reprs
    } : (reprs != null ? reprs[0] : void 0) || {};
    return cb(null, repr);
  });
};

groupItemsByPrimitiveTypes = function(items, resolvedTypes, cb) {
  var groups, i, item, nonPrimitiveItems, primitiveItems, typeName, _i, _len;
  primitiveItems = {};
  nonPrimitiveItems = [];
  for (i = _i = 0, _len = items.length; _i < _len; i = ++_i) {
    item = items[i];
    typeName = resolvedTypes[i].name;
    if (inspect.isPrimitive(typeName)) {
      if (primitiveItems[typeName] == null) {
        primitiveItems[typeName] = [];
      }
      primitiveItems[typeName].push(item);
    } else {
      nonPrimitiveItems.push(item);
    }
  }
  groups = (function() {
    var _results;
    _results = [];
    for (typeName in primitiveItems) {
      if (!__hasProp.call(primitiveItems, typeName)) continue;
      items = primitiveItems[typeName];
      _results.push({
        typeName: typeName,
        items: items,
        values: [],
        strategy: null
      });
    }
    return _results;
  })();
  return cb(null, groups, nonPrimitiveItems);
};

inspectEnumItems = function(items, nestedTypeName, cb) {
  return resolveTypes(items, nestedTypeName, function(err, resolvedTypes) {
    if (err) {
      return cb(err);
    }
    return groupItemsByPrimitiveTypes(items, resolvedTypes, function(err, groups, nonPrimitiveItems) {
      var group, hasSamples, _i, _len;
      if (err) {
        return cb(err);
      }
      for (_i = 0, _len = groups.length; _i < _len; _i++) {
        group = groups[_i];
        hasSamples = inspect.haveVariableValues(group.items);
        group.strategy = hasSamples ? 'singleType' : 'values';
      }
      return cb(null, {
        inline: false,
        groups: groups,
        nonPrimitiveItems: nonPrimitiveItems
      });
    });
  });
};

inspectEnumInline = function(enumElement, nestedTypeName, cb) {
  var group, strategy, values;
  if (inspect.hasVariableValues(enumElement)) {
    values = [];
    strategy = 'singleType';
  } else {
    values = inspect.listValues(enumElement);
    strategy = 'values';
  }
  group = {
    typeName: nestedTypeName,
    items: [],
    values: values,
    strategy: strategy
  };
  return cb(null, {
    inline: true,
    nonPrimitiveItems: [],
    groups: [group]
  });
};

inspectEnum = function(enumElement, resolvedType, cb) {
  var items, nestedTypeName, _ref2;
  if (resolvedType.nested.length > 1) {
    return cb(new Error("Multiple nested types for enum."));
  }
  nestedTypeName = (_ref2 = resolvedType.nested) != null ? _ref2[0] : void 0;
  items = inspect.listItems(enumElement);
  if (items.length) {
    return inspectEnumItems(items, nestedTypeName, cb);
  } else {
    return inspectEnumInline(enumElement, nestedTypeName, cb);
  }
};

handleEnumElement = function(enumElement, resolvedType, inherited, cb) {
  var fixed, heritage;
  if (inspect.isSample(enumElement)) {
    return cb(null, {});
  }
  fixed = inspect.isOrInheritsFixed(enumElement, inherited);
  heritage = inspect.getHeritage(fixed, resolvedType);
  return inspectEnum(enumElement, resolvedType, function(err, context) {
    if (err) {
      return cb(err);
    }
    context.inherited = heritage;
    return buildEnumRepr(context, cb);
  });
};

handlePrimitiveElement = function(primitiveElement, resolvedType, inherited, cb) {
  var fixed, insideEnum, vals;
  insideEnum = inherited.parentTypeName === 'enum';
  fixed = insideEnum || inspect.isOrInheritsFixed(primitiveElement, inherited);
  if (fixed) {
    vals = inspect.listValues(primitiveElement, true);
    if (vals.length) {
      if (vals.length > 1) {
        return cb(new Error("Primitive type can't have multiple values."));
      }
      return buildValueRepr(vals[0], resolvedType.name, cb);
    }
  }
  return cb(null, {
    type: resolvedType.name
  });
};

createElementHandler = function(resolvedType) {
  switch (resolvedType.name) {
    case 'object':
      return handleObjectElement;
    case 'array':
      return handleArrayElement;
    case 'enum':
      return handleEnumElement;
    default:
      return handlePrimitiveElement;
  }
};

handleElement = function(element, inherited, cb) {
  return resolveType(element, inherited.typeName, function(err, resolvedType) {
    var handle;
    if (err) {
      return cb(err);
    }
    handle = createElementHandler(resolvedType);
    return handle(element, resolvedType, inherited, function(err, repr) {
      if (err) {
        return cb(err);
      }
      return addDescription(element, repr, function(err, repr) {
        if (err) {
          return cb(err);
        }
        return addDefault(element, resolvedType, repr, cb);
      });
    });
  });
};

addSchemaDeclaration = function(repr, cb) {
  repr["$schema"] = "http://json-schema.org/draft-04/schema#";
  return cb(null, repr);
};

transform = function(ast, cb) {
  return handleElement(inspect.getAsElement(ast), {}, function(err, repr) {
    if (err) {
      return cb(err);
    }
    return addSchemaDeclaration(repr, cb);
  });
};

module.exports = {
  transform: transform
};
