// Generated by CoffeeScript 1.7.1
var async, buildArrayRepr, buildEnumRepr, buildObjectRepr, coerceLiteral, coerceNestedLiteral, createElementHandler, detectSuccessful, handleArrayElement, handleElement, handleEnumElement, handleObjectElement, handlePrimitiveElement, inspect, resolveArrayItems, resolveEnumItems, resolveItem, resolveOneOf, resolveOneOfGroup, resolveProperties, resolveProperty, resolveType, transform, _ref;

async = require('async');

inspect = require('../inspect');

detectSuccessful = require('../utils').detectSuccessful;

resolveType = require('../typeresolution').resolveType;

_ref = require('../jsonutils'), coerceLiteral = _ref.coerceLiteral, coerceNestedLiteral = _ref.coerceNestedLiteral;

resolveProperty = function(prop, inherited, cb) {
  return handleElement(prop, inherited, function(err, repr) {
    if (err) {
      return cb(err);
    }
    return cb(null, {
      name: inspect.findPropertyName(prop),
      repr: repr
    });
  });
};

resolveOneOf = function(oneofElement, inherited, cb) {
  var element;
  element = oneofElement.content[0];
  if (element["class"] === 'group') {
    return resolveOneOfGroup(element, inherited, cb);
  } else {
    return resolveProperty(element, inherited, function(err, resolvedProp) {
      return cb(err, (!err ? [resolvedProp] : void 0));
    });
  }
};

resolveOneOfGroup = function(groupElement, inherited, cb) {
  return async.mapSeries(groupElement.content, function(prop, next) {
    return resolveProperty(prop, inherited, next);
  }, cb);
};

resolveProperties = function(props, inherited, cb) {
  var results;
  results = [];
  return async.eachSeries(props, function(prop, next) {
    if (prop["class"] === 'oneOf') {
      if (!prop.content.length) {
        return next();
      }
      return resolveOneOf(prop, inherited, function(err, resolvedProps) {
        results = results.concat(resolvedProps);
        return next(err);
      });
    } else {
      return resolveProperty(prop, inherited, function(err, resolvedProp) {
        results.push(resolvedProp);
        return next(err);
      });
    }
  }, function(err) {
    return cb(err, results);
  });
};

buildObjectRepr = function(_arg, cb) {
  var repr, resolvedProps, rp, _i, _len;
  resolvedProps = _arg.resolvedProps;
  repr = {};
  for (_i = 0, _len = resolvedProps.length; _i < _len; _i++) {
    rp = resolvedProps[_i];
    repr[rp.name] = rp.repr;
  }
  return cb(null, repr);
};

handleObjectElement = function(objectElement, resolvedType, inherited, cb) {
  var fixed, heritage, props;
  fixed = inspect.isOrInheritsFixed(objectElement, inherited);
  heritage = inspect.getHeritage(fixed, resolvedType);
  props = inspect.listProperties(objectElement);
  return resolveProperties(props, heritage, function(err, resolvedProps) {
    if (err) {
      return cb(err);
    }
    return buildObjectRepr({
      resolvedProps: resolvedProps
    }, cb);
  });
};

resolveItem = function(item, inherited, cb) {
  return handleElement(item, inherited, function(err, repr) {
    if (err) {
      return cb(err);
    }
    return cb(null, {
      repr: repr
    });
  });
};

resolveArrayItems = function(items, multipleInherited, cb) {
  var inherited;
  if (multipleInherited.length === 1) {
    inherited = multipleInherited[0];
    return async.mapSeries(items, function(item, next) {
      return resolveItem(item, inherited, next);
    }, cb);
  } else {
    return async.mapSeries(items, function(item, next) {
      return detectSuccessful(multipleInherited, function(inherited, done) {
        return resolveItem(item, inherited, done);
      }, next);
    }, cb);
  }
};

buildArrayRepr = function(_arg, cb) {
  var arrayElement, fixed, repr, resolvedItems, resolvedType, ri, vals;
  arrayElement = _arg.arrayElement, resolvedItems = _arg.resolvedItems, resolvedType = _arg.resolvedType, fixed = _arg.fixed;
  if (resolvedItems.length) {
    if (fixed) {
      repr = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = resolvedItems.length; _i < _len; _i++) {
          ri = resolvedItems[_i];
          _results.push(ri.repr);
        }
        return _results;
      })();
    } else {
      repr = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = resolvedItems.length; _i < _len; _i++) {
          ri = resolvedItems[_i];
          if (ri.repr !== null) {
            _results.push(ri.repr);
          }
        }
        return _results;
      })();
    }
    return cb(null, repr);
  }
  if (fixed) {
    if (resolvedType.nested.length > 1) {
      return cb(new Error("Multiple nested types for fixed array."));
    }
    vals = inspect.listValues(arrayElement);
  } else {
    vals = inspect.listValuesOrSamples(arrayElement);
  }
  return async.mapSeries(vals, function(val, next) {
    return coerceNestedLiteral(val.literal, resolvedType.nested, next);
  }, cb);
};

handleArrayElement = function(arrayElement, resolvedType, inherited, cb) {
  var fixed, heritages, items;
  fixed = inspect.isOrInheritsFixed(arrayElement, inherited);
  heritages = inspect.listPossibleHeritages(fixed, resolvedType);
  items = inspect.listItems(arrayElement);
  return resolveArrayItems(items, heritages, function(err, resolvedItems) {
    if (err) {
      return cb(err);
    }
    return buildArrayRepr({
      arrayElement: arrayElement,
      resolvedItems: resolvedItems,
      resolvedType: resolvedType,
      fixed: fixed
    }, cb);
  });
};

resolveEnumItems = function(items, inherited, cb) {
  var item;
  item = items != null ? items[0] : void 0;
  if (!item) {
    return cb(null, null);
  }
  return resolveItem(item, inherited, cb);
};

buildEnumRepr = function(_arg, cb) {
  var enumElement, resolvedItem, resolvedType, vals;
  enumElement = _arg.enumElement, resolvedItem = _arg.resolvedItem, resolvedType = _arg.resolvedType;
  if (resolvedItem) {
    return cb(null, resolvedItem.repr);
  }
  if (resolvedType.nested.length > 1) {
    return cb(new Error("Multiple nested types for enum."));
  }
  vals = inspect.listValuesOrSamples(enumElement);
  if (vals.length) {
    return coerceLiteral(vals[0].literal, resolvedType.nested[0], cb);
  } else {
    return cb(null, null);
  }
};

handleEnumElement = function(enumElement, resolvedType, inherited, cb) {
  var fixed, heritage, items;
  fixed = inspect.isOrInheritsFixed(enumElement, inherited);
  heritage = inspect.getHeritage(fixed, resolvedType);
  items = inspect.listItems(enumElement);
  return resolveEnumItems(items, heritage, function(err, resolvedItem) {
    if (err) {
      return cb(err);
    }
    return buildEnumRepr({
      enumElement: enumElement,
      resolvedItem: resolvedItem,
      resolvedType: resolvedType
    }, cb);
  });
};

handlePrimitiveElement = function(primitiveElement, resolvedType, inherited, cb) {
  var vals;
  vals = inspect.listValues(primitiveElement);
  if (vals.length) {
    if (vals.length > 1) {
      return cb(new Error("Primitive type can't have multiple values."));
    }
    return coerceLiteral(vals[0].literal, resolvedType.name, cb);
  }
  return cb(null, null);
};

createElementHandler = function(resolvedType) {
  switch (resolvedType.name) {
    case 'object':
      return handleObjectElement;
    case 'array':
      return handleArrayElement;
    case 'enum':
      return handleEnumElement;
    default:
      return handlePrimitiveElement;
  }
};

handleElement = function(element, inherited, cb) {
  return resolveType(element, inherited.typeName, function(err, resolvedType) {
    var handle;
    if (err) {
      return cb(err);
    }
    handle = createElementHandler(resolvedType);
    return handle(element, resolvedType, inherited, cb);
  });
};

transform = function(ast, cb) {
  return handleElement(inspect.getAsElement(ast), {}, cb);
};

module.exports = {
  transform: transform
};
